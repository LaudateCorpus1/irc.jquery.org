[10:57:25] <ariya> morning/afternoon!
[11:00:50] <mikesherov> hello!
[11:02:29] <mikesherov> nzakas1: ikarienator caridy1 ariya ready?
[11:02:37] <ariya> ready
[11:02:40] <mikesherov> seems like a short agenda today
[11:02:44] <jeffmo> hai
[11:02:48] <mikesherov> Hi jeffmo
[11:03:06] <mikesherov> Anyone have interesting updates since last meeting?
[11:03:29] <ariya> I have no progress nor updates
[11:03:35] <caridy1> same here...
[11:03:53] <jeffmo> Same. Mostly heads down on flow-modules and class properties proposal here
[11:04:18] <mikesherov> ikarienator: has the cover grammar for destructuring done
[11:04:26] <ariya> I think destructring from @ikarienator mostly looks really good
[11:04:35] <mikesherov> yeah, that was a huuuge one
[11:04:57] <mikesherov> nzakas1: do you have any tests you can share with us for destructuring?
[11:05:05] <mikesherov> Want to make sure we have good overlap there
[11:05:33] <nzakas1> yeah, I think we added a few along the way
[11:05:46] <mikesherov> nzakas1: just point me to some source files?
[11:06:18] <nzakas1> I think this commit has the tests we made: https://github.com/eslint/espree/commit/0ddf4929be7897b410aad4d1ac9a7d1b3ddc2232
[11:06:40] <nzakas1> in general, destructuring tests are here: https://github.com/eslint/espree/tree/master/tests/fixtures/ecma-features/destructuring
[11:06:55] <mikesherov> ikarienator: see if you can incorporate some of those, lets make sure we catch any bugs in each others impls
[11:07:37] <mikesherov> as far as template strings go
[11:08:00] <mikesherov> there were a few bugs in harmony, mostly around LegacyOctalLiteralEscapeSequences
[11:08:31] <mikesherov> we've landed on `\08` and `\09` and `\9` and `\8` being errors even though v8 currently excepts them
[11:08:54] <mikesherov> Anyone object to that?
[11:09:01] <mikesherov> ikarienator: thanks for sticking with me on that one :-)
[11:09:06] <mikesherov> I'm the layman here
[11:09:21] <nzakas1> no objections here
[11:09:25] <ariya> Firefox/SM also rejects that
[11:09:30] <ariya> aka, \08 is an error there
[11:09:37] * jeffmo doesn’t pay close enough attention to text encoding to have opinions here
[11:09:51] <ariya> thus, any cross-browser JS code will avoid it anyway
[11:09:57] <mikesherov> ok, just making sure
[11:10:24] <mikesherov> nzakas1: you'll have to back port there, just as a heads up
[11:10:30] <nzakas1> yup
[11:10:32] <mikesherov> That is, if you care about that bug
[11:10:38] <mikesherov> which you may not :-)
[11:10:55] <mikesherov> breaks that nice consolidation the implementor in espree had :-\
[11:12:15] <ariya> mikesherov: other than that, template literal is ready for landing?
[11:12:25] <mikesherov> yeah, in both master and harmony
[11:12:31] <mikesherov> been trying to be a good citizen there
[11:12:46] <mikesherov> harmony is going to miss ikarienator's destructuring though :-(
[11:13:35] <mikesherov> ok, next topic then?
[11:13:40] <ikarienator> Hi
[11:13:46] <mikesherov> hi ikarienator :-)
[11:14:00] <mikesherov> https://github.com/estree/estree/pull/57
[11:14:08] <mikesherov> lets settle on landing superExpression?
[11:14:23] <mikesherov> SM has said they'll follow us
[11:14:53] <ariya> is it going to be for Esprima 2.x or 3.0?
[11:14:57] <ariya> we already shipped classes
[11:15:04] <mikesherov> 3.0
[11:15:13] <ariya> sounds good then
[11:15:22] <ariya> note that it is not possible to have a transition here
[11:15:22] <mikesherov> yeah, I'll file esprima issue
[11:15:25] <ariya> it will be quite confusion
[11:15:38] <nzakas1> I disagree
[11:15:52] <mikesherov> nzakas1: do tell
[11:15:53] <nzakas1> no more confusing than shipping "name" and then changing to "id"
[11:16:05] <nzakas1> traversals will still work
[11:16:10] <ariya> nzakas1: name?
[11:16:17] <nzakas1> yup, for class
[11:16:20] <mikesherov> right
[11:16:26] <ariya> was that in a release?
[11:16:39] <ikarienator> What is SuperExpression?
[11:16:52] <nzakas1> https://github.com/jquery/esprima/issues/1095
[11:16:53] <ikarienator> I think super is never an expression
[11:17:10] <ariya> nzakas1: CMIIW but 2.1 is already using id
[11:17:27] <nzakas1> yup, after 2.0 used name
[11:17:40] <michaelficarra> ikarienator: https://github.com/estree/estree/issues/54
[11:17:43] <nzakas1> that's a much more breaky than adding SuperExpression (or equivalent)
[11:17:43] <ikarienator> That was my bad...
[11:18:01] <mikesherov> no, 2.1.0 had the correct thing
[11:18:07] <ariya> nzakas1: 2.0 never had class
[11:18:10] <mikesherov> no released version of esprima had wrong thing
[11:18:22] <mikesherov> But yes, SuperExpression is wrong name
[11:18:25] <nzakas1> ah, hmmm, ok, I got confused
[11:18:27] <mikesherov> it should just be Super
[11:18:28] <ariya> mikesherov: my point ^^^
[11:18:40] <mikesherov> ariya: I'm agreeing :-)
[11:18:59] <mikesherov> michaelficarra: made point about SuperExpression just being named Super
[11:19:07] <mikesherov> because it's not an expression
[11:19:42] <mikesherov> and we can avoid mess where everyone thinks its liskov substitutible for another expression
[11:20:07] <mikesherov> anyway, we'll add in 3.0 then
[11:20:27] <ariya> sounds good
[11:21:16] <mikesherov> ok, moving on
[11:21:18] <ikarienator> We shall actually add tests from Shift.
[11:21:34] <ariya> ikarienator: which tests?
[11:21:44] <mikesherov> for destructuring :-)
[11:21:49] <mikesherov> ikarienator: is catching up :-)
[11:21:51] <ikarienator> Yes
[11:22:02] <ikarienator> Sorry about that
[11:22:10] <mikesherov> ikarienator: both
[11:22:27] <mikesherov> we want to catch espree bugs too if we are to be good upstream parents to nzakas1
[11:22:41] <mikesherov> and jeffmo :-)
[11:23:21] <ikarienator> nzakas1: is https://github.com/eslint/espree/tree/master/tests/fixtures/ecma-features/destructuring all the tests for destructuring?
[11:23:39] <nzakas1> those are all the tests for just destructuring
[11:23:47] <nzakas1> there are some that mix destructuring with other features
[11:24:10] <nzakas1> see: https://github.com/eslint/espree/tree/master/tests/fixtures/ecma-features-mix and search for "destructuring"
[11:24:57] <ikarienator> Ah nice!
[11:25:25] <mikesherov> ok, so can we move on?
[11:25:43] <mikesherov> Lets talk 2015 goals for a moment
[11:25:52] <ariya> Full ES6 support!
[11:26:12] <mikesherov> One thing about being in the jQuery Foundation is that we are *supposed* to provide goals to the foundation so they can allocate funds if necessary
[11:26:21] <mikesherov> or garner support in other ways
[11:26:29] <mikesherov> solicit help from other orgs, etc.
[11:26:52] <mikesherov> Full ES6 Support is defintiely a goal. I think we should aim to get that done though before ES6 comes out
[11:26:59] <mikesherov> like in next 2 months
[11:27:10] <ariya> definitely
[11:27:38] <mikesherov> so, lets say by June 1st the latest?
[11:27:51] <mikesherov> does that seem too aggressive, not aggressive enough?
[11:27:54] <ariya> fits into the “summer edition”
[11:28:07] <ariya> sounds sensible
[11:28:12] <mikesherov> that would culminate with last in 2.0 line, and release of 3.0
[11:28:19] <ariya> there could be still a long tail of bug fixes etc
[11:28:23] <mikesherov> sure
[11:28:33] <ariya> we still don’t have a good plan for those pesky early errors
[11:28:35] <mikesherov> but get same level of support as espree and acorn
[11:28:51] <mikesherov> ariya, sure, but we've nailed almost all big chunks save for generators now
[11:29:02] <ariya> module as well
[11:29:10] <mikesherov> caridy1: ahem :-)
[11:29:13] <mikesherov> ;-)
[11:29:30] <michaelficarra> ariya: if our two-phase parsing experiment in Shift goes well, you'll probably want to adopt that approach for early errors in esprima
[11:29:38] <mikesherov> michaelficarra: yes
[11:29:44] <mikesherov> we are watching closely :-)
[11:29:45] <ariya> for everyone reference: https://github.com/jquery/esprima/issues/1099
[11:29:57] <ariya> michaelficarra: sure
[11:30:31] <ariya> michaelficarra: it already goes well for typescript (albeit it’s more its diagnostic, not strictly errors only)
[11:30:47] <mikesherov> https://github.com/estree/estree/pull/32 is a blocker to new.target
[11:30:54] <mikesherov> let's try to resolve that as well today then too?
[11:31:22] <mikesherov> seems like last real blocker
[11:31:29] <mikesherov> actually, we're getting sidetracked
[11:31:34] <mikesherov> back to goals for a moment
[11:31:51] <mikesherov> so we're going to have last of 2.0 line by June 1st
[11:32:29] <mikesherov> and release 3.0 with whatever EsTree corrections we need to have, and any other BC changes (removing guardedhandlers and handlers)
[11:32:40] <ariya> true
[11:32:49] <mikesherov> I'd like to then add another goal
[11:33:05] <ariya> ES7?
[11:33:08] <ariya> :-)
[11:33:25] <mikesherov> *without* devolving into 2 pass parsing and discussions of complexity, I really really think we need a way to allow people to specify ES5 or ES6
[11:33:32] <caridy1> @mikesherov, I will get the modules done before going on sabbatical, on april.
[11:33:40] <mikesherov> the dumb easy way is literally just release esprima 1.2.5 as esprima-es5
[11:33:44] <ariya> caridy1: take your time, let me know if you need some help
[11:33:50] <mikesherov> thanks caridy1
[11:33:59] <ariya> mikesherov: run-time language choice? I think it’s fair
[11:34:01] <jeffmo> caridy1: sabbatical!?
[11:34:27] <mikesherov> like literally, we can release esprima-es5 and that solves this whole mess (until es7)
[11:34:49] <mikesherov> and with es7, we can figure out best approach, as feature flags might be only option there
[11:35:15] <ariya> are you referring to one package that supports ES5 + ES6?
[11:35:17] <mikesherov> but honestly, I'm getting lots of requests in JSCS for es5 only mode, and it's preventing me from upgrading to esprima 2.1
[11:35:40] <mikesherov> I'm referring to anything other than having the package named esprima support es5 modfe
[11:35:48] <ariya> surething
[11:35:58] <ariya> I also want to understand more on that ES5 mode for JSCS
[11:36:03] <mikesherov> literally, having a semver mean language difference is the only solution that *doesn't work*
[11:36:25] <mikesherov> it's why jQuery rebranded jquery 1.x and jquery 2.x as jquery-compat 3.x and jquery 3.x
[11:37:08] <mikesherov> people expect style enforcers, even if they are just style enforcers, to throw up when they use imaginary language features
[11:37:11] <jeffmo> mikesherov: so not divolving into 2-pass parsing seems a bit unfair since that is a member of the set of solutions to the “es5” vs “es6” discussion
[11:37:24] <mikesherov> jeffmo: we devolved on that last week
[11:37:29] <ariya> to be fair, I don’t think we want to add new language features to 1.x
[11:37:33] <ariya> ES5 doesn’t move anymore
[11:37:33] <mikesherov> just trying to discuss alternate approach
[11:37:39] <mikesherov> ariya, that's my point
[11:37:39] <jeffmo> mikesherov: ok
[11:37:50] <mikesherov> we just release 1.2.5 as esprima-es5
[11:37:53] <mikesherov> and then I'm happy
[11:38:03] <mikesherov> I can have JSCS depend on both esprima-es5 and esprima
[11:38:09] <mikesherov> and the controversy is done
[11:38:15] <ikarienator> I think it's OK to have divergence in 1.x branch, so I think keep them separate is a good idea to me.
[11:38:17] <ariya> didn’t I propose this some time ago? :-)
[11:38:18] <ariya> https://gist.github.com/ariya/0d465b26113981c4eef1
[11:38:24] <mikesherov> ariya you did :-)
[11:38:37] <mikesherov> I am now agreeing with you on that because feature flags is a sticking point for us
[11:38:45] <mikesherov> and 2 pass approach is too experimental
[11:38:54] <ikarienator> I think this will be the least confusion solution.
[11:39:08] <ariya> if we want to be pragmatic, sure
[11:39:19] <ariya> it doesn’t mean that feature flags or language flags are out of the question
[11:39:20] <ikarienator> A language flag can introduce a lot of bugs and performance issues.
[11:39:23] <mikesherov> I don't think we need wrapper packages
[11:39:31] <mikesherov> just release 1 new package, esprima-es5
[11:39:46] <michaelficarra> we're going to need at least another 2 months of experimenting before anybody can seriously recommend 2-phase parsing
[11:39:46] <mikesherov> ikarienator: but we need to try
[11:39:49] <mikesherov> for es7 that is
[11:40:21] <mikesherov> for es5 we can agree that it's time to release a new package, and *if* we do language flags, it'll be because they're straightforward and performant
[11:40:57] <ariya> to add to michaelficarra’s point, it’s only safe to do flags after all early errors are known and tested
[11:41:13] <ariya> otherwise, we might regress easily and walk back again for something that we promise
[11:41:18] <mikesherov> right, which is why for es6 vs. es5, it's a quagmire discussion
[11:41:27] <mikesherov> has bared no fruit for us for 5 meetings :-)
[11:41:29] <jeffmo> 2 months to decide if a second-pass traversal that asserts on unexpected things will do what it sounds like it will do?
[11:41:37] <mikesherov> with es7, we have a bit of time for this to marinate
[11:41:41] <ariya> http://www.merriam-webster.com/dictionary/quagmire
[11:41:46] <ariya> for ikarienator  and my benefit :-)
[11:42:00] <mikesherov> the Iraq war is a quagmire
[11:42:11] <mikesherov> "getting stuck in the mud"
[11:42:14] <mikesherov> "going nowhere"
[11:42:18] <ariya> I’m all for it
[11:42:26] <ikarienator> Whoa, English has so many words for same things.
[11:42:27] <michaelficarra> war?
[11:42:40] <mikesherov> Just want to hear from nzakas1 here
[11:42:43] <ariya> though I still personally investigate and evaluate lang/feature flags in the style of espree and acorn
[11:42:52] <mikesherov> because he is good sounding board for downstream projects
[11:43:13] <nzakas1> quagmires are bad
[11:43:23] <mikesherov> nzakas1: LOL
[11:43:32] <nzakas1> I've following the conversation, just not sure where to chime in
[11:43:47] <mikesherov> I meant, if we release esprima-es5, seems like that solves the eslint case of "user wants to specify es5 only
[11:43:59] <mikesherov> just means you have another dep
[11:44:09] <nzakas1> only if we also remove the non-ES5 pieces (like let and const)
[11:44:17] <mikesherov> nzakas1: yes, I want that too
[11:44:18] <ariya> but eslint parser is already configurable
[11:44:30] <mikesherov> The goal is to remove the eslint parser
[11:44:35] <mikesherov> and make espree a real fork
[11:44:40] <nzakas1> right
[11:44:47] <mikesherov> espree exists because of feature flags at this point
[11:44:57] <ariya> what I mean is the choice of parser can be specified at run-time for eslint
[11:44:59] <mikesherov> all other sticking points have been removed
[11:45:07] <mikesherov> ariya, that is true
[11:45:15] <mikesherov> but it needs to be esprima-like
[11:45:20] <mikesherov> same with JSCS
[11:45:21] <ariya> es5linter is eslint + es5 parser
[11:45:28] <nzakas1> to refresh
[11:45:33] <nzakas1> the long-term goal is to not have Espree
[11:45:38] <mikesherov> THIS ^
[11:45:50] <nzakas1> for that to happen, we need to be able to specify language features
[11:46:00] <nzakas1> if we can get a pure ES5 Esprima parser, then that solves the baseline problem
[11:46:10] <ariya> let and const are fair to remove
[11:46:13] <ariya> now that we have 2.x
[11:46:18] <nzakas1> and then the next step is to deal with the ES6 pieces
[11:46:27] <nzakas1> so the ES5 parser is the first incremental step towards that goal
[11:46:27] <ariya> will probably call it 1.3, since it can’t be in patch version bump
[11:46:46] <mikesherov> ariya, no, it's called esprima-es5 1.0
[11:47:00] <mikesherov> it's a separate package :-)
[11:47:23] <ariya> logistics :-)
[11:47:29] <michaelficarra> are we going to return to the MetaProperty discussion?
[11:47:36] <mikesherov> michaelficarra: yes in a moment
[11:47:43] <mikesherov> 2015 goals have been defeerred twice :-\
[11:47:49] <ariya> so language choice as a goal for 2015?
[11:47:57] <michaelficarra> just wondering
[11:48:06] <mikesherov> nzakas1: the es6 pieces was only stop gap for dealing with potential implementation bugs in es6
[11:48:08] <ariya> (regardless what the implementation is and how it will evolve behind the scene)
[11:48:23] <mikesherov> if we have es5 vs. es6 that seems to sovle it until es7 and jsx
[11:48:33] <ariya> surething
[11:48:34] <mikesherov> yes, language choice
[11:48:38] <nzakas1> yup
[11:48:38] <ariya> JSX is a fair addition to 3.0
[11:48:41] <ariya> jeffmo: ^^^
[11:49:33] <mikesherov> to sum up: the goal is full es6 support, releasing esprima-es5, and esprima 3.0 by June 1
[11:49:52] <mikesherov> by end of year, we need a solution for JSX as plugin at worst, JSX in core at best
[11:49:55] <ariya> let me give some though on that esprima-es5 (as the name, not concept)
[11:50:02] <mikesherov> sure, ariya
[11:50:21] <nzakas1> es5prima
[11:50:25] <mikesherov> LOL
[11:50:25] <nzakas1> just because :)
[11:50:27] <mikesherov> YES
[11:50:27] <jeffmo> ariya: did discussion on feature flags change (i.e. for toggling JSX parsing) ? or do you mean just out of the box?
[11:50:56] <jeffmo> Ah, I missed mikesherov’s last comment on JSX
[11:51:17] <ariya> jeffmo: even better, if we know what hooks to be exposed so that it can be e.g. a plugin
[11:51:29] <jeffmo> ariya: got it
[11:51:29] <mikesherov> jeffmo: 3 options for JSX: core behind language flag, core out of the box, as a plguin (which infers externalizing sub parse functions)
[11:51:38] <jeffmo> yep
[11:51:38] <mikesherov> but goal is still the same
[11:51:45] <mikesherov> make esprima-fb not have to be full fork
[11:51:53] <mikesherov> just plugin maintainence
[11:52:07] <mikesherov> OK, any other goals for 2015?
[11:52:09] <ariya> not related to 2015 feature goals, but should we strive for e.g. type annotating the source code?
[11:52:19] <jeffmo> mikesherov: +1 — esprima-fb + flow parser are a huge source of work for me right now. Part of the reason I’ve found it hard to spend time on esprima-master too
[11:52:24] <ariya> I can easily see Flow or TypeScript to be useful here
[11:52:32] <mikesherov> ariya, sure.
[11:52:44] <mikesherov> OK, anyone else with 2015 goals?
[11:53:02] * ariya doesn’t have more ideas
[11:53:05] <mikesherov> This of course assumes ESTree work is completed as well.
[11:53:12] <mikesherov> I have one more idea, implement a CST
[11:53:20] <mikesherov> but don't want to gaurantee that as a goal for us
[11:53:22] <mikesherov> it's a thought
[11:53:38] <nzakas1> still unsure of the value of a CST, personally
[11:53:51] <ariya> it’s almost like an entirely different project
[11:53:57] <nzakas1> yes
[11:54:11] <ariya> we should encourage a fork
[11:54:13] <jeffmo> I’d be far more interested in solving the needs for a CST in creative ways within esprima and/or ESTree
[11:54:28] <mikesherov> well, the reason is to enable a pipeline
[11:54:34] <ariya> just fork esprima, augment it with CST, and then it’s easy to see the value/diff
[11:54:36] <mikesherov> we can defer this discussion for later
[11:54:41] <mikesherov> but if everyone wants speed
[11:54:55] <jeffmo> Having to switch between completely different data structures for different static analysis is pretty unfortunate, and I’m not sure I’m convinced that AST and CST aren’t just abstract concepts
[11:55:07] <jeffmo> anyway, defering discussion is fine with me
[11:55:12] <mikesherov> all linters / transpilers / formatters should be able to accept a *lossless* tree as input and spit one out as output
[11:55:20] <jeffmo> yep, I agree
[11:55:20] <nzakas1> +1 for deferring
[11:55:27] <mikesherov> Let's defer
[11:55:36] <mikesherov> MetaProperty, let's squeeze in
[11:55:37] <mikesherov> michaelficarra:
[11:56:28] <ariya> JFYI, I have no data point to pick a side on MetaProperty
[11:56:29] <mikesherov> https://github.com/estree/estree/pull/32
[11:56:43] <mikesherov> If we don't care strongly, let's defer to consensus
[11:56:43] * ariya now has an excuse to read the spec again
[11:56:46] <michaelficarra> awesome
[11:56:47] <mikesherov> but michaelficarra might care
[11:56:52] <michaelficarra> I do
[11:56:59] <mikesherov> michaelficarra: ALWAYS CARES :-)
[11:57:14] <ariya> michaelficares
[11:57:16] <mikesherov> glad to have you there catching my bumbles
[11:57:27] <michaelficarra> I propose `interface MetaProperty <: Expression { type: "MetaProperty"; kind: "new.target"; }`
[11:57:46] <mikesherov> and anyone disagreed?
[11:57:57] <michaelficarra> kyle simpson
[11:58:25] <mikesherov> did any implementors disagree?
[11:58:34] <mikesherov> where is sebmck and rreverser stand?
[11:58:35] <michaelficarra> his reasoning is that it may hurt concrete syntax representation in the future
[11:58:49] <mikesherov> yes, he is always concerned with that isn't he
[11:58:55] <mikesherov> that seems like phantom concern
[11:58:58] <michaelficarra> his proposal was to represent the "new" and "target" parts separately
[11:59:09] <mikesherov> -1 on that for me
[11:59:18] <michaelficarra> agreed that it's not a concern we can consider at this point with no working CST proposal
[11:59:39] <mikesherov> My CST proposal is additive to the tree anyway
[11:59:45] <mikesherov> nothing is locked in *anyway*
[12:00:14] <mikesherov> Anyone have opinions here, or should we just support Michael's position?
[12:00:17] <nzakas1> michaelficarra: you had earlier proposed "object" and "property"
[12:00:21] <nzakas1> just curious why now "kind"?
[12:00:43] * ariya is fine with MetaProperty as proposed above
[12:01:15] <ikarienator> I just tested and acorn-babel (as the one on npm) doesn't support new.target
[12:01:16] <ariya> “…since the components of a meta property aren't individually meaningful.”
[12:01:18] <mikesherov> ah, position of the `.` will be lost
[12:01:18] <michaelficarra> my comment from the issue: "I don't see a reason to split them on . since the components of a meta property aren't individually meaningful."
[12:01:36] <michaelficarra> ariya beat me to it
[12:01:47] <ariya> michaelficarra: as usual :-)
[12:01:47] <jeffmo> MetaProperty makes sense to me (over MembExpr)
[12:01:49] <mikesherov> ah, so always collapse
[12:02:46] <jeffmo> What would be the downsides of having individual nodes for each of these metapropertis as well?
[12:02:46] <mikesherov> hmm
[12:02:51] <jeffmo> NewTarget
[12:02:57] <michaelficarra> well I wouldn't colour it as "collapsing"
[12:03:12] <michaelficarra> it's just an indicator of which MetaProperty it is
[12:03:31] <michaelficarra> jeffmo: that would work as well, but is not really consistent with the rest of the SpiderMonkey spec
[12:03:31] <mikesherov> well, if I see the position of `new.target` is at multiline, I must guess where the newline actually is
[12:03:51] <mikesherov> but that's back to your point of meaningless *anyway
[12:03:55] <mikesherov> anyway*
[12:04:01] <jeffmo> michaelficarra: where else? I’m thinking of ThisExperssion and the Super refs as an example where it seems simliar
[12:04:36] <jeffmo> mikesherov: can you have a newline between ‘new’, ‘.’, and ‘target’ ?
[12:04:39] <michaelficarra> and Literal and VariableDeclaration where it is not
[12:04:41] <jeffmo> I suppose so
[12:04:45] <michaelficarra> jefmo: ^
[12:04:46] <mikesherov> jeffmo: yes
[12:05:14] <jeffmo> Ah, in that case I’d be in favor of something that makes it at least possible to extend the node in the future such that positional information can be pulled out
[12:05:30] <jeffmo> kind = “target” seems mostly friendly to that
[12:05:43] <jeffmo> allows inclusion of location info for “target"
[12:05:54] <mikesherov> but this seems like a spectre
[12:05:57] <jeffmo> but keeps the outer node singular in that it wraps the inner
[12:06:05] <michaelficarra> jeffmo: you mean positional info for each component of the MetaProperty?
[12:06:16] <mikesherov> I think ultimately, we're considering an extreme edgecase of a sociopath
[12:06:22] <jeffmo> michaelficarra: yes, given that ‘new’, ‘.’, and ‘target’ can sit separated syntactically
[12:06:24] <mikesherov> writing:
[12:06:25] <mikesherov> new.
[12:06:28] <mikesherov> target
[12:06:31] <mikesherov> like a crazy person
[12:06:46] <nzakas1> you know as well as I do such people exist :)
[12:06:52] <jeffmo> mikesherov: meh, all styles are crazy if you ask the right person :)
[12:06:57] <mikesherov> Yes
[12:07:25] <mikesherov> Additive
[12:07:33] <mikesherov> so we can start with michaelficarra 's proposal
[12:07:42] <mikesherov> and if crazy lunatic needs position info so bad
[12:07:50] <jeffmo> Anyway, I agree with the notion of not overloading member expression, and I like a MetaProperty node — but I do think it would be very practically useful to have ‘target’ sit as, at least, a sub-node of MetaProperty if only for purposes of location tracking
[12:08:10] <mikesherov> the MetaProperty can additively get additional properties to convey the necessary info for crazypants
[12:08:12] <michaelficarra> I'm not saying it won't happen, but we can make a less-than-optimal-but-still-okay representation of position information for those crazy people
[12:08:14] <ariya> like the nested MemberExpression (object)?
[12:08:26] <jeffmo> ariya: yes
[12:08:31] <nzakas1> I gotta run, but +1 to jeffmo's comment
[12:08:33] <jeffmo> but immediately distinguishable from it
[12:08:59] <mikesherov> jeffmo: because it's additive, we can add it later when needed
[12:09:26] <jeffmo> mikesherov: it’s medium-additive if kind is a string
[12:09:33] <jeffmo> (means a breaking change later)
[12:09:40] <mikesherov> we can keep kind
[12:09:47] <ariya> mikesherov: JCSC will need that loc information
[12:09:56] <ariya> e.g. when disallowing spaces between object and property
[12:09:59] <mikesherov> ariya, it most certainly will
[12:10:05] <mikesherov> but JSCS is using the token list for that
[12:10:12] <jeffmo> I’m not saying getting rid of kind — that’s fine. Just that it should probably be a full-on sub-node rather than just a string
[12:10:15] <mikesherov> we use AST to get kinds of structures to look at
[12:10:24] <mikesherov> and then go to linked tokens to get concrete info
[12:10:25] <ariya> michaelficarra: so going back to object+property?
[12:10:32] <mikesherov> it's where my proposal for CST comes from :-)
[12:11:04] <jeffmo> mikesherov: *sigh* I have so much to say on the CST topic, but want to stay true to our commitment to defer :)
[12:11:07] <mikesherov> jeffmo: I was saying keep kind a string, and add separate nodes later that represent the component pieces
[12:11:23] <jeffmo> mikesherov: that seems pretty different from how location info works anywhere else though
[12:11:38] <ariya> mikesherov: but JSCS will need it right away, why adding it later?
[12:11:43] <jeffmo> mikesherov: what’s the downside of a sub-node?
[12:11:49] <mikesherov> JSCS will have it on day 1 :-)
[12:12:03] <ikarienator> Are we sure that there will be no additional things added to the MetaProperty in the future when new meta properties are introduced?
[12:12:06] <mikesherov> because it will know that Metaproperty has a firstToken of "new"
[12:12:12] <mikesherov> and lastToken of "target"
[12:12:16] <michaelficarra> I only have a problem with object+property because it's *not* a member access, it is only syntactically similar to one
[12:12:17] <mikesherov> with punctuator in the middle
[12:12:22] <ikarienator> If we are not sure about that, we should use a new node NewTarget instead.
[12:12:29] <mikesherov> it doesn't give a shit about position info in the AST portion :-)
[12:12:38] <ikarienator> That will be the least breakable definition.
[12:12:54] <jeffmo> ikarienator: there almost certainly will be new things other than just ‘target'
[12:12:59] <ariya> michaelficarra: sure, it doesn’t have to that name
[12:13:11] <ikarienator> We can define an super class MetaProperty and NewTarget <: MetaProperty
[12:13:28] <mikesherov> all metproperties will *look* like a memberExpression, yes?
[12:13:41] <ariya> I gotta run, will catch up later
[12:13:44] <ariya> thanks folks!
[12:13:48] <mikesherov> I have tog o too
[12:13:49] <jeffmo> ikarienator: only problem there is that we don’t have a good place to distinguish location info for ‘new’ vs ‘target’ (which can have whitespace between them)
[12:13:51] <mikesherov> thanks ariya
[12:13:58] <ikarienator> Then we can use type to determine which is which and, the last but not least, we don't need to bike shed about the naming in kind.
[12:14:14] <mikesherov> right, naming bikeshed and type are least of concern
[12:14:19] <mikesherov> both just bikesheds
[12:14:21] <jeffmo> ikarienator: I don’t care if we call it ‘kind’ relaly — just what the type of that node-property is
[12:14:33] <mikesherov> actually question is around single "kind" field that is lossier than necessary
[12:14:38] <jeffmo> I actually think type is a little important — wouldn’t classify that bikeshedding
[12:14:54] <mikesherov> ok, fair enough
[12:15:04] <mikesherov> I'll go with whatever direction
[12:15:08] <mikesherov> JSCS doesn't care
[12:15:12] <ikarienator> That's the job of a CST. We don't represent parentheses as well, that's more serious than new.target
[12:15:16] <jeffmo> we can go with a string — we just have to accept that that’s going to be a breaking change down the road if we want location info for it (and I’m pretty sure such info will be useful fairly quickly)
[12:15:45] <mikesherov> jeffmo: only if we change value of kind
[12:15:46] <jeffmo> ikarienator: in that case, should we drop location info in the AST altogether?
[12:15:51] <mikesherov> not if we add other props on the side
[12:16:03] <mikesherov> jeffmo: we don't have location info in the AST :-)
[12:16:07] <jeffmo> mikesherov: if we didn’t change the value of kind, we’d be hacking on another location property that doesn’t match how location info is attached elswhere in the spec
[12:16:21] <mikesherov> no, not location property
[12:16:28] <mikesherov> *kind* would still have location info
[12:16:45] <mikesherov> I'm saying we'd add "object" and "property" properties that have their own location info
[12:16:49] <jeffmo> oh ok, so kind is an object with, say, a ‘value’ and a ‘loc’ property?
[12:16:50] <ikarienator> mikesherov: I propose to not have a `kind`.
[12:16:52] <mikesherov> kind would have location info
[12:17:02] <mikesherov> ikarienator: that's cool;
[12:17:07] <mikesherov> duke it out with michaelficarra
[12:17:13] <jeffmo> mikesherov: can you write out an example object literal that esprima might generate? just for clarity?
[12:17:14] <mikesherov> I propose an arm wrestling match :-)
[12:17:33] <michaelficarra> whatever Bei wants
[12:17:48] <ikarienator> Michael Bei do that a lot.
[12:18:13] <mikesherov> { type: 'metaProperty', kind: 'new.target', loc: [ <start line and column>, <end line and column> ] };
[12:18:32] <mikesherov> And if people clamored, extend that to:
[12:18:33] <jeffmo> mikesherov: how do you determine where the ‘new’ ends and the ‘target’ starts?
[12:18:44] <mikesherov> jeffmo: you don't currently
[12:18:50] <mikesherov> but if you needed to in future:
[12:18:50] <jeffmo> I’m saying that’s important
[12:18:54] <jeffmo> oh ok, go ahead...
[12:19:41] <mikesherov> { type: 'metaProperty', kind: 'new.target', object: { value: "new", loc: [...] }, property: { value: "new", loc: [...] },  loc: [ <start line and column>, <end line and column> ] };
[12:19:49] <ikarienator> jeffmo: why is that more important than the location of parentheses?
[12:20:01] <jeffmo> I’m proposing: {type: ‘MetaProperty’, kind: {type: ‘NewTarget’, loc: { /* loc info for ‘target’ */ }}, loc: { /* loc info for the full production */ }} <— (All strings in that example are open to bikeshed, I’m looking for structure)
[12:20:21] <mikesherov> jeffmo: right, you are proptimizing for that info
[12:20:34] <jeffmo> mikesherov: what’s the downside of doing so ahead of time?
[12:20:40] <ikarienator> jeffmo: When you have location information, you can get the source code for that range. And it will contain more than the location of the new token and the target token.
[12:20:57] <mikesherov> unnecessary burden for linters to figure out what kind of metaProperty it is
[12:21:23] <mikesherov> if all metaProperty nodes look like memberExpressions
[12:21:26] <jeffmo> mikesherov: node.type === ‘MetaProperty’ && node.kind.type === ‘NewTarget’ ?
[12:21:38] <mikesherov> jeffmo: OH
[12:21:42] <mikesherov> I missed that part
[12:21:46] <jeffmo> ikarienator: I think the fact that you can’t extract parens from the ST is something to be solved — so I wouldn’t use it as justification for furthering that problem
[12:21:51] <mikesherov> ikarienator: 's question still stands though
[12:22:03] <mikesherov> yeah, something to be solved certainly
[12:22:39] <ikarienator> { type: "NewTarget, loc: {...}, range: {...} }
[12:22:44] <mikesherov> yeah
[12:22:51] <mikesherov> ikarienator: seems like the right answer there
[12:22:56] <michaelficarra> jeffmo: grouping parentheses don't belong in an AST
[12:23:07] <jeffmo> michaelficarra: they belong in some kind of ST
[12:23:15] <jeffmo> I don’t want to deal with two kinds of STs
[12:23:22] <mikesherov> jeffmo: DEFER
[12:23:25] <jeffmo> sorry :)
[12:23:26] <michaelficarra> ^
[12:23:30] <mikesherov> because what type is the  {type: ‘NewTarget’, loc: { /* loc info for ‘target’ */ } ?
[12:23:38] <mikesherov> ikarienator: is only option for your world jeffmo
[12:23:47] <mikesherov> base abstract metaproperty
[12:23:57] <mikesherov> that all concrete metaproperties extend
[12:23:58] <jeffmo> mikesherov: Node? Or if it needs a base-class, sure
[12:24:12] <ikarienator> Yes NewTarget <: MetaProperty
[12:24:18] <mikesherov> yeah
[12:24:20] <ikarienator> the location for the whole thing
[12:24:33] <michaelficarra> NewTargetExpression?
[12:24:37] <jeffmo> wait, NewTarget goes inside of something that represents ‘new.<<something>>’ though —else we’re back at square one
[12:24:43] <mikesherov> wait wait
[12:24:55] <jeffmo> {type: ‘MetaProperty’, kind: {type: ‘NewTarget’, loc: { /* loc info for ‘target’ */ }}, loc: { /* loc info for the full production */ }}
[12:25:07] <jeffmo> (I don’t like those names — but again, I’m only talking about structure right now)
[12:25:17] <mikesherov> how does {type: ‘MetaProperty’, kind: {type: ‘NewTarget’, loc: { /* loc info for ‘target’ */ }}, loc: { /* loc info for the full production */ }}  make sense
[12:25:29] <mikesherov> jeffmo: where is the location info for "new" in that world
[12:25:31] <jeffmo> MetaProperty represents ‘new.<<something>>’
[12:25:40] <ikarienator> Why do you need to wrap it?
[12:25:51] <michaelficarra> jeffmo: are you assuming all MetaProperties will be of the form `new.<something>`?
[12:25:52] <jeffmo> mikesherov: it’s NewTarget.end - MetaProperty.end
[12:25:57] <ikarienator> in the future there will be more x.y s
[12:25:57] <jeffmo> mikesherov: yes
[12:26:05] <mikesherov> MetaProperty represents '<<something>>.<<scomething>>'
[12:26:10] <michaelficarra> ^
[12:26:13] <ikarienator> for example function.arguments
[12:26:13] <jeffmo> err, sorry I meant: michaelficarra: yes
[12:26:23] <mikesherov> jeffmo that leaves us not knowing where "new" ends
[12:26:25] <jeffmo> ikarienator: ah, ok
[12:26:27] <michaelficarra> jeffmo: that's not the case
[12:26:42] <jeffmo> we can specify “new” vs “function” in the toplevel-wrapper-node then
[12:26:49] <jeffmo> ok ok
[12:26:51] <jeffmo> this makes sense
[12:26:55] <mikesherov> we are back at {type: 'MetaProperty', object: 'new', property: 'target'}
[12:27:06] <jeffmo> mikesherov: yes, ok that makes more sense to me now
[12:27:22] <michaelficarra> recent related es-discuss thread: https://esdiscuss.org/topic/proposal-additional-meta-properties-for-es7
[12:27:28] <jeffmo> I was running with the idea that MetaProperty was focused on the new class of ‘new.<<stuff>>’ productions that will be coming in the future
[12:28:08] <mikesherov> michaelficarra: are you against {type: 'MetaProperty', object: 'new', property: 'target'}
[12:28:16] <jeffmo> ok, so consider me converted to the latest structure that mikesherov typed — but with ‘object’ and ‘property’ themselves being nodes with location info
[12:28:29] <michaelficarra> I believe erights even brought up `=>.<something>` at the last TC39 meeting
[12:28:46] <mikesherov> {type: 'MetaProperty', object: '=>', property: '<something>'}
[12:28:57] <mikesherov> is that too literal for you, michaelficarra ?
[12:28:58] <michaelficarra> of what type would those nodes be?
[12:29:06] <mikesherov> they are all of type metaproperty
[12:29:18] <michaelficarra> (object + property)
[12:29:18] <mikesherov> we're inviting a ton of invalid metaproperty 's
[12:29:33] <mikesherov> but that is main difference between shift and estree
[12:29:42] <mikesherov> shift optimizes for least invalid productions
[12:29:42] <michaelficarra> strings? because strings don't have location info as jeffmo requests
[12:30:01] <mikesherov> michaelficarra: not literally strings
[12:30:07] <michaelficarra> then what?
[12:30:10] <mikesherov> Oh, wait yeah
[12:30:13] <mikesherov> I see the problem
[12:30:24] <michaelficarra> :-)
[12:30:26] <ikarienator> How about tokens?
[12:30:29] <mikesherov> not accurate to describe them as stringLiterals
[12:30:29] <michaelficarra> quagmire
[12:30:42] <mikesherov> michaelficarra: then metaObject
[12:30:43] <ikarienator> as we exposed in `tokenize`
[12:30:46] <mikesherov> metaPropertyt
[12:30:56] <mikesherov> metaPropertyProperty
[12:30:59] <mikesherov> LOL
[12:31:07] <jeffmo> {type: ‘MetaProperty’, object: {type: ‘MetaPropertyObject’, value: ‘new’, loc: { /* loc info for new */ }}, prop: {type: ‘MetaPropertyProperty’, value: ‘target’, loc: {/* loc info for ‘target’ */ }}, loc: {/* loc info for all */ }}
[12:31:13] <ikarienator> call them meta and property
[12:31:18] <jeffmo> mikesherov: ah you beat me to it on MetaPropertyProperty :)
[12:31:22] <mikesherov> right
[12:31:39] <mikesherov> {type: ‘MetaProperty’, meta: {type: ‘MetaPropertyObject’, value: ‘new’, loc: { /* loc info for new */ }}, property: {type: ‘MetaPropertyProperty’, value: ‘target’, loc: {/* loc info for ‘target’ */ }}, loc: {/* loc info for all */ }}
[12:31:47] <michaelficarra> +1 Meta and Property
[12:32:02] <jeffmo> Meta, MetaObject, MetaProperty ?
[12:32:06] <mikesherov> AH
[12:32:11] <mikesherov> beat me to it jeffmo
[12:32:25] <michaelficarra> -1 jeffmo
[12:32:30] <mikesherov> {type: ‘Meta’, meta: {type: ‘MetaObject’, value: ‘new’, loc: { /* loc info for new */ }}, property: {type: ‘MetaProperty’, value: ‘target’, loc: {/* loc info for ‘target’ */ }}, loc: {/* loc info for all */ }}
[12:32:36] <michaelficarra> MetaProperty is already a well-known name
[12:32:39] <mikesherov> yeah
[12:32:41] <michaelficarra> using it for anything but that is a bad idea
[12:32:53] <mikesherov> {type: ‘MetaProperty’, meta: {type: ‘MetaPropertyObject’, value: ‘new’, loc: { /* loc info for new */ }}, property: {type: ‘MetaPropertyProperty’, value: ‘target’, loc: {/* loc info for ‘target’ */ }}, loc: {/* loc info for all */ }}
[12:32:56] <jeffmo> mikesherov: ok, I care less about the names (as long as they aren’t completely unrelated) — more interested in the structure
[12:33:07] <mikesherov> michaelficarra: cool on that?
[12:33:07] <ikarienator> And it's not an object
[12:33:10] <jeffmo> ag, ‘mi<tab>’ doesnt ever do what I want :)
[12:33:15] <michaelficarra> I can live with it
[12:33:19] <michaelficarra> I think the justification was weak
[12:33:27] <mikesherov> {type: ‘MetaProperty’, meta: {type: ‘MetaPropertyTHINGAMABOB’, value: ‘new’, loc: { /* loc info for new */ }}, property: {type: ‘MetaPropertyProperty’, value: ‘target’, loc: {/* loc info for ‘target’ */ }}, loc: {/* loc info for all */ }}
[12:33:46] <jeffmo> SHIPIT
[12:33:47] <ikarienator> Wow you can do that in IRC??
[12:33:51] <mikesherov> yeah, justification not the strongest
[12:34:06] <jeffmo> I don’t know what you guys are talking about, I work out my justifications 7x a week
[12:34:10] <mikesherov> but seems to satisfy use cases that estree folk and consumers care about?
[12:34:28] <mikesherov> OK, jeffmo and michaelficarra can you report back on the threead?
[12:34:32] <michaelficarra> more like 7x a weak, amirite?
[12:34:35] <jeffmo> ehhhh
[12:34:36] <jeffmo> :p
[12:34:47] <jeffmo> mikesherov: will do
[12:35:13] <michaelficarra> I will +1 it
[12:35:34] <michaelficarra> I'm still for {MetaProperty {Meta} {Property}} naming
[12:35:57] <mikesherov> michaelficarra: Oh, I like that
[12:36:04] <jeffmo> michaelficarra: fine by me — I’ll use that in my comment on the GH issue
[12:36:05] <ikarienator> Let's talk next time folks!
[12:36:08] <mikesherov> but the types are what?
[12:36:14] <mikesherov> ok
[12:36:15] <mikesherov> bye!
[12:36:20] <ikarienator> bye!
[12:36:36] <michaelficarra> bye
